### Fundamentals of REST API

# What is REST API?

* REST = Representational State Transfer.
* It's a set of rules for building web APIs.
* Uses HTTP methods: GET, POST, PUT, DELETE.
* Works with resources identified by URLs.

# Key Principles

* **Stateless**: Server does not remember client state.
* **Client-Server**: Separation of concerns.
* **Cacheable**: Responses should say if they can be cached.
* **Uniform Interface**: Same method of communication across APIs.

# HTTP Methods

* `GET`: Read data.
* `POST`: Create data.
* `PUT`: Update data.
* `DELETE`: Remove data.

# Status Codes

* `200`: OK
* `201`: Created
* `400`: Bad Request
* `404`: Not Found
* `500`: Server Error

# Example

```http
GET /users/1
```

Response:

```json
{
  "id": 1,
  "name": "Ali"
}
```

---

# Introduction to Node.js & NPM

# What is Node.js?

* Runtime to run JavaScript on server.
* Built on Chrome's V8 engine.
* Uses non-blocking (async) code.

# Features

* Fast and scalable.
* Uses event-driven architecture.
* Ideal for APIs, real-time apps.

# Node.js Architecture

* Single-threaded with Event Loop.
* Handles many connections using callbacks.

# Core Modules

* `fs` for file system
* `http` to create web servers
* `path`, `url`, etc.

# Example

```js
const http = require('http');
http.createServer((req, res) => {
  res.end('Hello World');
}).listen(3000);
```

# NPM

* Node Package Manager
* Used to install libraries

Commands:

```bash
npm init -y
npm install express
```

---

# What is MongoDB?

* NoSQL database.
* Stores data in JSON-like documents.
* Used for flexible, scalable apps.

# Basic Terms

* **Database**: Container for collections.
* **Collection**: Group of documents.
* **Document**: Data record (like JSON).

# CRUD Operations

* **Create**: `insertOne`, `insertMany`
* **Read**: `find`, `findOne`
* **Update**: `updateOne`, `updateMany`
* **Delete**: `deleteOne`, `deleteMany`

# Example:

```js
// Insert
await db.collection('users').insertOne({ name: 'Ali' });

// Find
const user = await db.collection('users').findOne({ name: 'Ali' });

// Update
await db.collection('users').updateOne({ name: 'Ali' }, { $set: { age: 25 } });

// Delete
await db.collection('users').deleteOne({ name: 'Ali' });
```

# Schema (with Mongoose)

```js
const mongoose = require('mongoose');
const userSchema = new mongoose.Schema({
  name: String,
  age: Number,
});
const User = mongoose.model('User', userSchema);
```

# Aggregation Pipeline

* Used to transform data

```js
User.aggregate([
  { $match: { age: { $gt: 20 } } },
  { $group: { _id: "$age", count: { $sum: 1 } } }
]);
```

# Indexing

* Speeds up search queries.

```js
collection.createIndex({ name: 1 });
```

# ACID Properties

* **Atomicity**: All or nothing.
* **Consistency**: Valid state.
* **Isolation**: No mixed results.
* **Durability**: Data is saved.

# Replication

* Copies data across multiple servers.
* Provides high availability.


 43 changes: 43 additions & 0 deletions43  
Week_7-6/Day-2-24-July-2025/Lecture.md
Viewed
Original file line number	Diff line number	Diff line change
@@ -0,0 +1,43 @@
# Project Setup and Structure

- A Node.js REST API project is created using `npm init`.
- Installed Express with `npm install express`.
- Server listens on port `8000`.
- Created basic Express app.

# REST API Routes Overview

- `GET /users`: List all users.
- `GET /users/:id`: Get one user by ID.
- `POST /users`: Add new user.
- `PATCH /users/:id`: Update user by ID.
- `DELETE /users/:id`: Delete user by ID.

# Mock Data Generation

- Used **Mockaroo** to generate fake users data in JSON format.
- Fields: `id`, `first_name`, `last_name`, `email`, `gender`, `job_title`.
- Saved data to project folder.

# GET /api/users Route

- Returns all users in JSON.
- Visit `localhost:8000/api/users` to see JSON data.

# Hybrid Server Design

- Used `/api/*` for JSON (API clients).
- Used `/users` for HTML (browser clients).
- `/users` shows HTML list of users.

# Dynamic Route for Single User

- Route: `/api/users/:id`
- Uses `req.params.id` to get ID.
- Returns matching user object.

# POST, PATCH, DELETE Basics

- Used Postman for testing.
- Setup basic routes: POST, PATCH, DELETE.
- Used `app.route('/api/users/:id')` to group routes by path.
 246 changes: 246 additions & 0 deletions246  
Week_7-6/Day-3-25-July-2025/Lecture.md
Viewed
Original file line number	Diff line number	Diff line change
@@ -0,0 +1,246 @@
# Node Cron – Task Scheduling

# What is Node Cron?
- A Node.js module to run tasks at specific times.

# Install

npm install node-cron

# Example
```js
const cron = require('node-cron');

cron.schedule('*/2 * * * * *', () => {
  console.log('Runs every 2 seconds');
});
```

# Error Check

```js
if (error != 0) {
  console.log("Something went wrong");
}
```

---

# Node.js vs Express.js

* Node.js: Base for creating servers.
* Express.js: Framework to simplify Node.js with routing, responses, etc.

---

# Express Basics

```js
const express = require('express');
const app = express();

app.get('/', (req, res) => res.send('Home'));
app.listen(3000);
```

* Add more routes: `/profile`, `/contact`

# Middleware

```js
app.use((req, res, next) => {
  console.log("Middleware");
  next();
});
```

# req, res, next

* `req`: Request data
* `res`: Response to client
* `next`: Move to next middleware

# Dynamic Routes

```js
app.get('/user/:name', (req, res) => {
  res.send(req.params.name);
});
```

---

# EJS Template Engine

# Setup

```js
app.set('view engine', 'ejs');
```

# Render

```js
res.render('index', { age: 12 });
```

# In EJS

```html
<p>Age: <%= age %></p>
```

---

# Static Files

```js
app.use(express.static('./public'));
```

Use files like:

```html
<link href="/css/style.css" />
```

---

# Error Handling
```js
app.use((err, req, res, next) => {
  res.render('error', { message: err.message });
});
```

```js
next(new Error("Something went wrong"));
```

---

# Supabase – Firebase Alternative

* Uses PostgreSQL
* Offers auth, storage, real-time, database

# Start

* Go to [supabase.com](https://supabase.com)
* Create project

# Tables

* Add columns
* Enable Role Level Security (RLS)
* Use rules per role (anon, authenticated)

---

# Supabase + React

```bash
npm install @supabase/supabase-js
```

```js
import { createClient } from '@supabase/supabase-js';
const supabase = createClient(URL, ANON_KEY);
```

---

# CRUD

# Insert

```js
await supabase.from('tasks').insert({ title: 'Task' });
```

# Read

```js
await supabase.from('tasks').select('*');
```

# Update

```js
await supabase.from('tasks').update({ done: true }).eq('id', 1);
```

# Delete

```js
await supabase.from('tasks').delete().eq('id', 1);
```

---

# Auth

# Sign Up / In

```js
await supabase.auth.signUp({ email, password });
await supabase.auth.signInWithPassword({ email, password });
```

# Session

```js
const { data: { session } } = await supabase.auth.getSession();
```

# Auth Change

```js
supabase.auth.onAuthStateChange((event, session) => {
  setSession(session);
});
```

# Sign Out

```js
await supabase.auth.signOut();
```

---

# Real-Time

```js
supabase.channel('tasks_channel')
  .on('postgres_changes', {
    event: 'INSERT',
    schema: 'public',
    table: 'tasks'
  }, (payload) => {
    // handle payload
  })
  .subscribe();
```

---

# Storage

# Upload

```js
await supabase.storage.from('task_images').upload(filePath, file);
```

# Get URL

```js
const { data } = await supabase.storage.from('task_images').getPublicUrl(filePath);
```

# Show Image

```html
<img src={image_URL} />
```
 73 changes: 73 additions & 0 deletions73  
Week_7-6/Day-4-28-July-2025/Lecture.md
Viewed
Original file line number	Diff line number	Diff line change
@@ -0,0 +1,73 @@
# Redis + JWT Authentication + Browser Storage

# 1. Redis (In-Memory Data Store)

Redis is an open-source, in-memory key-value data store used to improve application performance by acting as a temporary storage layer between the server and the main database. Since Redis stores data in RAM, it responds very quickly, making it ideal for caching frequently requested data like user profiles, product lists, or calculated results.

When a request is made, the server first checks Redis. If the data is found (called a cache hit), it is returned instantly. If not (cache miss), the server fetches data from the actual database, saves it in Redis for future requests, and then returns it.

Redis supports many data types:
- **Strings** for simple values like counters or tokens.
- **Lists** for queues or logs.
- **Sets** for unique collections (e.g., online users).
- **Hashes** for storing objects like user profiles with multiple fields.
- **Sorted Sets** for leaderboards or ranked data.
- **Streams** for event logs.
- **Geospatial data**, **bitmaps**, and time-series modules are also available for specific use cases.

It also supports **Pub/Sub** messaging, useful for real-time notifications or chat systems.

Redis can be installed on any system or run using Docker. For JavaScript applications, libraries like `ioredis` allow you to interact with Redis programmatically.


## 2. JWT Authentication in React

JWT (JSON Web Token) is a way to securely identify users after login. Once a user logs in successfully, the server sends two tokens to the front-end: an **access token** and a **refresh token**.

The **access token** is used to authorize API requests and has a short lifespan (usually 5 to 15 minutes). This token is stored in memory (like a React state or context), so it disappears when the browser is closed, reducing the risk of misuse if stolen.

The **refresh token** has a longer lifespan (hours or days) and is stored in an **HTTP-only cookie**, which is not accessible via JavaScript. This keeps it safe from attacks like cross-site scripting (XSS).

When the access token expires, the app silently uses the refresh token to request a new one by calling the `/refresh` endpoint. If successful, the app updates its access token and retries the failed request. If the refresh token is also expired or invalid, the user is redirected to the login page.

To implement this in React:
- Create a `useRefreshToken` hook that calls the `/refresh` endpoint and updates the auth state.
- Use an Axios instance (`axiosPrivate`) with **interceptors** that:
  - Automatically attach the access token to each request.
  - Catch 403 errors, refresh the token, and retry the request.
- Use React Router's `useNavigate` and `useLocation` to redirect users when login is needed again.

This setup ensures users stay logged in smoothly without manually refreshing tokens or handling errors.


## 3. Browser Storage (Cookies, Local Storage, Session Storage)

Browsers offer three main ways to store data on the client side: **cookies**, **local storage**, and **session storage**. All of them allow you to store data that belongs to a particular user and browser.

**Cookies** are small pieces of data (limited to around 4 KB) that are automatically sent to the server with every HTTP request. This makes them ideal for authentication purposes. Cookies can be given an expiration time, and they are accessible by both the browser and server (unless marked HTTP-only). However, cookies are more complex to manage through JavaScript.

**Local Storage** allows you to store up to 10 MB of string data in the browser. It is persistent, meaning the data stays available even after closing and reopening the browser. Local storage is best for things like user preferences, dark mode settings, or shopping cart contents.

**Session Storage** is similar to local storage but is limited to 5 MB and only lasts as long as the browser tab is open. Once the tab is closed, the data is cleared. It's useful for temporary form inputs or one-time session data.

All these storage types are browser- and user-specific. If you save data in Chrome, it won’t appear in Firefox or for another user on the same computer. Users can clear this stored data any time from browser settings.

To view or manage these storage options:
- Open Developer Tools in Chrome or Firefox.
- Go to the **Application** tab.
- Look under "Storage" to inspect Local Storage, Session Storage, and Cookies.

You can interact with them like this:

```js
// Local Storage
localStorage.setItem('name', 'Ali');
localStorage.getItem('name');
localStorage.removeItem('name');

// Session Storage
sessionStorage.setItem('theme', 'dark');
sessionStorage.getItem('theme');

// Cookies
document.cookie = "user=Ali";
